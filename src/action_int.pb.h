// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: action_int.proto

#ifndef PROTOBUF_action_5fint_2eproto__INCLUDED
#define PROTOBUF_action_5fint_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_action_5fint_2eproto();
void protobuf_AssignDesc_action_5fint_2eproto();
void protobuf_ShutdownFile_action_5fint_2eproto();

class Action;

// ===================================================================

class Action : public ::google::protobuf::Message {
 public:
  Action();
  virtual ~Action();
  
  Action(const Action& from);
  
  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Action& default_instance();
  
  void Swap(Action* other);
  
  // implements Message ----------------------------------------------
  
  Action* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string client = 1;
  inline bool has_client() const;
  inline void clear_client();
  static const int kClientFieldNumber = 1;
  inline const ::std::string& client() const;
  inline void set_client(const ::std::string& value);
  inline void set_client(const char* value);
  inline void set_client(const char* value, size_t size);
  inline ::std::string* mutable_client();
  inline ::std::string* release_client();
  
  // optional string client_action_id = 2;
  inline bool has_client_action_id() const;
  inline void clear_client_action_id();
  static const int kClientActionIdFieldNumber = 2;
  inline const ::std::string& client_action_id() const;
  inline void set_client_action_id(const ::std::string& value);
  inline void set_client_action_id(const char* value);
  inline void set_client_action_id(const char* value, size_t size);
  inline ::std::string* mutable_client_action_id();
  inline ::std::string* release_client_action_id();
  
  // optional bool substantiated = 3;
  inline bool has_substantiated() const;
  inline void clear_substantiated();
  static const int kSubstantiatedFieldNumber = 3;
  inline bool substantiated() const;
  inline void set_substantiated(bool value);
  
  // optional string backend = 11;
  inline bool has_backend() const;
  inline void clear_backend();
  static const int kBackendFieldNumber = 11;
  inline const ::std::string& backend() const;
  inline void set_backend(const ::std::string& value);
  inline void set_backend(const char* value);
  inline void set_backend(const char* value, size_t size);
  inline ::std::string* mutable_backend();
  inline ::std::string* release_backend();
  
  // optional string action_type = 12;
  inline bool has_action_type() const;
  inline void clear_action_type();
  static const int kActionTypeFieldNumber = 12;
  inline const ::std::string& action_type() const;
  inline void set_action_type(const ::std::string& value);
  inline void set_action_type(const char* value);
  inline void set_action_type(const char* value, size_t size);
  inline ::std::string* mutable_action_type();
  inline ::std::string* release_action_type();
  
  // optional bool read_only = 13 [default = false];
  inline bool has_read_only() const;
  inline void clear_read_only();
  static const int kReadOnlyFieldNumber = 13;
  inline bool read_only() const;
  inline void set_read_only(bool value);
  
  // optional bytes input = 14;
  inline bool has_input() const;
  inline void clear_input();
  static const int kInputFieldNumber = 14;
  inline const ::std::string& input() const;
  inline void set_input(const ::std::string& value);
  inline void set_input(const char* value);
  inline void set_input(const void* value, size_t size);
  inline ::std::string* mutable_input();
  inline ::std::string* release_input();
  
  // optional bytes output = 15;
  inline bool has_output() const;
  inline void clear_output();
  static const int kOutputFieldNumber = 15;
  inline const ::std::string& output() const;
  inline void set_output(const ::std::string& value);
  inline void set_output(const char* value);
  inline void set_output(const void* value, size_t size);
  inline ::std::string* mutable_output();
  inline ::std::string* release_output();
  
  // repeated int32 readset = 21;
  inline int readset_size() const;
  inline void clear_readset();
  static const int kReadsetFieldNumber = 21;
  inline ::google::protobuf::int32 readset(int index) const;
  inline void set_readset(int index, ::google::protobuf::int32 value);
  inline void add_readset(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      readset() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_readset();
  
  // repeated int32 writeset = 22;
  inline int writeset_size() const;
  inline void clear_writeset();
  static const int kWritesetFieldNumber = 22;
  inline ::google::protobuf::int32 writeset(int index) const;
  inline void set_writeset(int index, ::google::protobuf::int32 value);
  inline void add_writeset(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      writeset() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_writeset();
  
  // optional uint64 version = 31;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 31;
  inline ::google::protobuf::uint64 version() const;
  inline void set_version(::google::protobuf::uint64 value);
  
  // optional bool disallow_lazy_scheduling = 41 [default = false];
  inline bool has_disallow_lazy_scheduling() const;
  inline void clear_disallow_lazy_scheduling();
  static const int kDisallowLazySchedulingFieldNumber = 41;
  inline bool disallow_lazy_scheduling() const;
  inline void set_disallow_lazy_scheduling(bool value);
  
  // optional int32 state = 42;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 42;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);
  
  // optional uint64 closure = 43;
  inline bool has_closure() const;
  inline void clear_closure();
  static const int kClosureFieldNumber = 43;
  inline ::google::protobuf::uint64 closure() const;
  inline void set_closure(::google::protobuf::uint64 value);
  
  // optional uint64 start_time = 44;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 44;
  inline ::google::protobuf::uint64 start_time() const;
  inline void set_start_time(::google::protobuf::uint64 value);
  
  // optional uint64 exec_start_time = 45;
  inline bool has_exec_start_time() const;
  inline void clear_exec_start_time();
  static const int kExecStartTimeFieldNumber = 45;
  inline ::google::protobuf::uint64 exec_start_time() const;
  inline void set_exec_start_time(::google::protobuf::uint64 value);
  
  // optional uint64 end_time = 46;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 46;
  inline ::google::protobuf::uint64 end_time() const;
  inline void set_end_time(::google::protobuf::uint64 value);
  
  // optional bool delayed = 47;
  inline bool has_delayed() const;
  inline void clear_delayed();
  static const int kDelayedFieldNumber = 47;
  inline bool delayed() const;
  inline void set_delayed(bool value);
  
  // repeated uint64 read_deps = 51;
  inline int read_deps_size() const;
  inline void clear_read_deps();
  static const int kReadDepsFieldNumber = 51;
  inline ::google::protobuf::uint64 read_deps(int index) const;
  inline void set_read_deps(int index, ::google::protobuf::uint64 value);
  inline void add_read_deps(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      read_deps() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_read_deps();
  
  // repeated uint64 write_deps = 52;
  inline int write_deps_size() const;
  inline void clear_write_deps();
  static const int kWriteDepsFieldNumber = 52;
  inline ::google::protobuf::uint64 write_deps(int index) const;
  inline void set_write_deps(int index, ::google::protobuf::uint64 value);
  inline void add_write_deps(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      write_deps() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_write_deps();
  
  // repeated uint64 dependents = 53;
  inline int dependents_size() const;
  inline void clear_dependents();
  static const int kDependentsFieldNumber = 53;
  inline ::google::protobuf::uint64 dependents(int index) const;
  inline void set_dependents(int index, ::google::protobuf::uint64 value);
  inline void add_dependents(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      dependents() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_dependents();
  
  // optional int32 num_dependencies = 54;
  inline bool has_num_dependencies() const;
  inline void clear_num_dependencies();
  static const int kNumDependenciesFieldNumber = 54;
  inline ::google::protobuf::int32 num_dependencies() const;
  inline void set_num_dependencies(::google::protobuf::int32 value);
  
  // optional bool materialize = 55;
  inline bool has_materialize() const;
  inline void clear_materialize();
  static const int kMaterializeFieldNumber = 55;
  inline bool materialize() const;
  inline void set_materialize(bool value);
  
  // @@protoc_insertion_point(class_scope:Action)
 private:
  inline void set_has_client();
  inline void clear_has_client();
  inline void set_has_client_action_id();
  inline void clear_has_client_action_id();
  inline void set_has_substantiated();
  inline void clear_has_substantiated();
  inline void set_has_backend();
  inline void clear_has_backend();
  inline void set_has_action_type();
  inline void clear_has_action_type();
  inline void set_has_read_only();
  inline void clear_has_read_only();
  inline void set_has_input();
  inline void clear_has_input();
  inline void set_has_output();
  inline void clear_has_output();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_disallow_lazy_scheduling();
  inline void clear_has_disallow_lazy_scheduling();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_closure();
  inline void clear_has_closure();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_exec_start_time();
  inline void clear_has_exec_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_delayed();
  inline void clear_has_delayed();
  inline void set_has_num_dependencies();
  inline void clear_has_num_dependencies();
  inline void set_has_materialize();
  inline void clear_has_materialize();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* client_;
  ::std::string* client_action_id_;
  ::std::string* backend_;
  ::std::string* action_type_;
  ::std::string* input_;
  ::std::string* output_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > readset_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > writeset_;
  bool substantiated_;
  bool read_only_;
  bool disallow_lazy_scheduling_;
  bool delayed_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::uint64 version_;
  ::google::protobuf::uint64 closure_;
  ::google::protobuf::uint64 start_time_;
  ::google::protobuf::uint64 exec_start_time_;
  ::google::protobuf::uint64 end_time_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > read_deps_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > write_deps_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > dependents_;
  ::google::protobuf::int32 num_dependencies_;
  bool materialize_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];
  
  friend void  protobuf_AddDesc_action_5fint_2eproto();
  friend void protobuf_AssignDesc_action_5fint_2eproto();
  friend void protobuf_ShutdownFile_action_5fint_2eproto();
  
  void InitAsDefaultInstance();
  static Action* default_instance_;
};
// ===================================================================


// ===================================================================

// Action

// optional string client = 1;
inline bool Action::has_client() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Action::set_has_client() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Action::clear_has_client() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Action::clear_client() {
  if (client_ != &::google::protobuf::internal::kEmptyString) {
    client_->clear();
  }
  clear_has_client();
}
inline const ::std::string& Action::client() const {
  return *client_;
}
inline void Action::set_client(const ::std::string& value) {
  set_has_client();
  if (client_ == &::google::protobuf::internal::kEmptyString) {
    client_ = new ::std::string;
  }
  client_->assign(value);
}
inline void Action::set_client(const char* value) {
  set_has_client();
  if (client_ == &::google::protobuf::internal::kEmptyString) {
    client_ = new ::std::string;
  }
  client_->assign(value);
}
inline void Action::set_client(const char* value, size_t size) {
  set_has_client();
  if (client_ == &::google::protobuf::internal::kEmptyString) {
    client_ = new ::std::string;
  }
  client_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Action::mutable_client() {
  set_has_client();
  if (client_ == &::google::protobuf::internal::kEmptyString) {
    client_ = new ::std::string;
  }
  return client_;
}
inline ::std::string* Action::release_client() {
  clear_has_client();
  if (client_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_;
    client_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string client_action_id = 2;
inline bool Action::has_client_action_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Action::set_has_client_action_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Action::clear_has_client_action_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Action::clear_client_action_id() {
  if (client_action_id_ != &::google::protobuf::internal::kEmptyString) {
    client_action_id_->clear();
  }
  clear_has_client_action_id();
}
inline const ::std::string& Action::client_action_id() const {
  return *client_action_id_;
}
inline void Action::set_client_action_id(const ::std::string& value) {
  set_has_client_action_id();
  if (client_action_id_ == &::google::protobuf::internal::kEmptyString) {
    client_action_id_ = new ::std::string;
  }
  client_action_id_->assign(value);
}
inline void Action::set_client_action_id(const char* value) {
  set_has_client_action_id();
  if (client_action_id_ == &::google::protobuf::internal::kEmptyString) {
    client_action_id_ = new ::std::string;
  }
  client_action_id_->assign(value);
}
inline void Action::set_client_action_id(const char* value, size_t size) {
  set_has_client_action_id();
  if (client_action_id_ == &::google::protobuf::internal::kEmptyString) {
    client_action_id_ = new ::std::string;
  }
  client_action_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Action::mutable_client_action_id() {
  set_has_client_action_id();
  if (client_action_id_ == &::google::protobuf::internal::kEmptyString) {
    client_action_id_ = new ::std::string;
  }
  return client_action_id_;
}
inline ::std::string* Action::release_client_action_id() {
  clear_has_client_action_id();
  if (client_action_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_action_id_;
    client_action_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool substantiated = 3;
inline bool Action::has_substantiated() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Action::set_has_substantiated() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Action::clear_has_substantiated() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Action::clear_substantiated() {
  substantiated_ = false;
  clear_has_substantiated();
}
inline bool Action::substantiated() const {
  return substantiated_;
}
inline void Action::set_substantiated(bool value) {
  set_has_substantiated();
  substantiated_ = value;
}

// optional string backend = 11;
inline bool Action::has_backend() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Action::set_has_backend() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Action::clear_has_backend() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Action::clear_backend() {
  if (backend_ != &::google::protobuf::internal::kEmptyString) {
    backend_->clear();
  }
  clear_has_backend();
}
inline const ::std::string& Action::backend() const {
  return *backend_;
}
inline void Action::set_backend(const ::std::string& value) {
  set_has_backend();
  if (backend_ == &::google::protobuf::internal::kEmptyString) {
    backend_ = new ::std::string;
  }
  backend_->assign(value);
}
inline void Action::set_backend(const char* value) {
  set_has_backend();
  if (backend_ == &::google::protobuf::internal::kEmptyString) {
    backend_ = new ::std::string;
  }
  backend_->assign(value);
}
inline void Action::set_backend(const char* value, size_t size) {
  set_has_backend();
  if (backend_ == &::google::protobuf::internal::kEmptyString) {
    backend_ = new ::std::string;
  }
  backend_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Action::mutable_backend() {
  set_has_backend();
  if (backend_ == &::google::protobuf::internal::kEmptyString) {
    backend_ = new ::std::string;
  }
  return backend_;
}
inline ::std::string* Action::release_backend() {
  clear_has_backend();
  if (backend_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = backend_;
    backend_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string action_type = 12;
inline bool Action::has_action_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Action::set_has_action_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Action::clear_has_action_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Action::clear_action_type() {
  if (action_type_ != &::google::protobuf::internal::kEmptyString) {
    action_type_->clear();
  }
  clear_has_action_type();
}
inline const ::std::string& Action::action_type() const {
  return *action_type_;
}
inline void Action::set_action_type(const ::std::string& value) {
  set_has_action_type();
  if (action_type_ == &::google::protobuf::internal::kEmptyString) {
    action_type_ = new ::std::string;
  }
  action_type_->assign(value);
}
inline void Action::set_action_type(const char* value) {
  set_has_action_type();
  if (action_type_ == &::google::protobuf::internal::kEmptyString) {
    action_type_ = new ::std::string;
  }
  action_type_->assign(value);
}
inline void Action::set_action_type(const char* value, size_t size) {
  set_has_action_type();
  if (action_type_ == &::google::protobuf::internal::kEmptyString) {
    action_type_ = new ::std::string;
  }
  action_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Action::mutable_action_type() {
  set_has_action_type();
  if (action_type_ == &::google::protobuf::internal::kEmptyString) {
    action_type_ = new ::std::string;
  }
  return action_type_;
}
inline ::std::string* Action::release_action_type() {
  clear_has_action_type();
  if (action_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = action_type_;
    action_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool read_only = 13 [default = false];
inline bool Action::has_read_only() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Action::set_has_read_only() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Action::clear_has_read_only() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Action::clear_read_only() {
  read_only_ = false;
  clear_has_read_only();
}
inline bool Action::read_only() const {
  return read_only_;
}
inline void Action::set_read_only(bool value) {
  set_has_read_only();
  read_only_ = value;
}

// optional bytes input = 14;
inline bool Action::has_input() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Action::set_has_input() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Action::clear_has_input() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Action::clear_input() {
  if (input_ != &::google::protobuf::internal::kEmptyString) {
    input_->clear();
  }
  clear_has_input();
}
inline const ::std::string& Action::input() const {
  return *input_;
}
inline void Action::set_input(const ::std::string& value) {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  input_->assign(value);
}
inline void Action::set_input(const char* value) {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  input_->assign(value);
}
inline void Action::set_input(const void* value, size_t size) {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  input_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Action::mutable_input() {
  set_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    input_ = new ::std::string;
  }
  return input_;
}
inline ::std::string* Action::release_input() {
  clear_has_input();
  if (input_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = input_;
    input_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes output = 15;
inline bool Action::has_output() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Action::set_has_output() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Action::clear_has_output() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Action::clear_output() {
  if (output_ != &::google::protobuf::internal::kEmptyString) {
    output_->clear();
  }
  clear_has_output();
}
inline const ::std::string& Action::output() const {
  return *output_;
}
inline void Action::set_output(const ::std::string& value) {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  output_->assign(value);
}
inline void Action::set_output(const char* value) {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  output_->assign(value);
}
inline void Action::set_output(const void* value, size_t size) {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  output_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Action::mutable_output() {
  set_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    output_ = new ::std::string;
  }
  return output_;
}
inline ::std::string* Action::release_output() {
  clear_has_output();
  if (output_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = output_;
    output_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated int32 readset = 21;
inline int Action::readset_size() const {
  return readset_.size();
}
inline void Action::clear_readset() {
  readset_.Clear();
}
inline ::google::protobuf::int32 Action::readset(int index) const {
  return readset_.Get(index);
}
inline void Action::set_readset(int index, ::google::protobuf::int32 value) {
  readset_.Set(index, value);
}
inline void Action::add_readset(::google::protobuf::int32 value) {
  readset_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Action::readset() const {
  return readset_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Action::mutable_readset() {
  return &readset_;
}

// repeated int32 writeset = 22;
inline int Action::writeset_size() const {
  return writeset_.size();
}
inline void Action::clear_writeset() {
  writeset_.Clear();
}
inline ::google::protobuf::int32 Action::writeset(int index) const {
  return writeset_.Get(index);
}
inline void Action::set_writeset(int index, ::google::protobuf::int32 value) {
  writeset_.Set(index, value);
}
inline void Action::add_writeset(::google::protobuf::int32 value) {
  writeset_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Action::writeset() const {
  return writeset_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Action::mutable_writeset() {
  return &writeset_;
}

// optional uint64 version = 31;
inline bool Action::has_version() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Action::set_has_version() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Action::clear_has_version() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Action::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
  clear_has_version();
}
inline ::google::protobuf::uint64 Action::version() const {
  return version_;
}
inline void Action::set_version(::google::protobuf::uint64 value) {
  set_has_version();
  version_ = value;
}

// optional bool disallow_lazy_scheduling = 41 [default = false];
inline bool Action::has_disallow_lazy_scheduling() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Action::set_has_disallow_lazy_scheduling() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Action::clear_has_disallow_lazy_scheduling() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Action::clear_disallow_lazy_scheduling() {
  disallow_lazy_scheduling_ = false;
  clear_has_disallow_lazy_scheduling();
}
inline bool Action::disallow_lazy_scheduling() const {
  return disallow_lazy_scheduling_;
}
inline void Action::set_disallow_lazy_scheduling(bool value) {
  set_has_disallow_lazy_scheduling();
  disallow_lazy_scheduling_ = value;
}

// optional int32 state = 42;
inline bool Action::has_state() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Action::set_has_state() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Action::clear_has_state() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Action::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 Action::state() const {
  return state_;
}
inline void Action::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// optional uint64 closure = 43;
inline bool Action::has_closure() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Action::set_has_closure() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Action::clear_has_closure() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Action::clear_closure() {
  closure_ = GOOGLE_ULONGLONG(0);
  clear_has_closure();
}
inline ::google::protobuf::uint64 Action::closure() const {
  return closure_;
}
inline void Action::set_closure(::google::protobuf::uint64 value) {
  set_has_closure();
  closure_ = value;
}

// optional uint64 start_time = 44;
inline bool Action::has_start_time() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Action::set_has_start_time() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Action::clear_has_start_time() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Action::clear_start_time() {
  start_time_ = GOOGLE_ULONGLONG(0);
  clear_has_start_time();
}
inline ::google::protobuf::uint64 Action::start_time() const {
  return start_time_;
}
inline void Action::set_start_time(::google::protobuf::uint64 value) {
  set_has_start_time();
  start_time_ = value;
}

// optional uint64 exec_start_time = 45;
inline bool Action::has_exec_start_time() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Action::set_has_exec_start_time() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Action::clear_has_exec_start_time() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Action::clear_exec_start_time() {
  exec_start_time_ = GOOGLE_ULONGLONG(0);
  clear_has_exec_start_time();
}
inline ::google::protobuf::uint64 Action::exec_start_time() const {
  return exec_start_time_;
}
inline void Action::set_exec_start_time(::google::protobuf::uint64 value) {
  set_has_exec_start_time();
  exec_start_time_ = value;
}

// optional uint64 end_time = 46;
inline bool Action::has_end_time() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Action::set_has_end_time() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Action::clear_has_end_time() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Action::clear_end_time() {
  end_time_ = GOOGLE_ULONGLONG(0);
  clear_has_end_time();
}
inline ::google::protobuf::uint64 Action::end_time() const {
  return end_time_;
}
inline void Action::set_end_time(::google::protobuf::uint64 value) {
  set_has_end_time();
  end_time_ = value;
}

// optional bool delayed = 47;
inline bool Action::has_delayed() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Action::set_has_delayed() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Action::clear_has_delayed() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Action::clear_delayed() {
  delayed_ = false;
  clear_has_delayed();
}
inline bool Action::delayed() const {
  return delayed_;
}
inline void Action::set_delayed(bool value) {
  set_has_delayed();
  delayed_ = value;
}

// repeated uint64 read_deps = 51;
inline int Action::read_deps_size() const {
  return read_deps_.size();
}
inline void Action::clear_read_deps() {
  read_deps_.Clear();
}
inline ::google::protobuf::uint64 Action::read_deps(int index) const {
  return read_deps_.Get(index);
}
inline void Action::set_read_deps(int index, ::google::protobuf::uint64 value) {
  read_deps_.Set(index, value);
}
inline void Action::add_read_deps(::google::protobuf::uint64 value) {
  read_deps_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Action::read_deps() const {
  return read_deps_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Action::mutable_read_deps() {
  return &read_deps_;
}

// repeated uint64 write_deps = 52;
inline int Action::write_deps_size() const {
  return write_deps_.size();
}
inline void Action::clear_write_deps() {
  write_deps_.Clear();
}
inline ::google::protobuf::uint64 Action::write_deps(int index) const {
  return write_deps_.Get(index);
}
inline void Action::set_write_deps(int index, ::google::protobuf::uint64 value) {
  write_deps_.Set(index, value);
}
inline void Action::add_write_deps(::google::protobuf::uint64 value) {
  write_deps_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Action::write_deps() const {
  return write_deps_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Action::mutable_write_deps() {
  return &write_deps_;
}

// repeated uint64 dependents = 53;
inline int Action::dependents_size() const {
  return dependents_.size();
}
inline void Action::clear_dependents() {
  dependents_.Clear();
}
inline ::google::protobuf::uint64 Action::dependents(int index) const {
  return dependents_.Get(index);
}
inline void Action::set_dependents(int index, ::google::protobuf::uint64 value) {
  dependents_.Set(index, value);
}
inline void Action::add_dependents(::google::protobuf::uint64 value) {
  dependents_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Action::dependents() const {
  return dependents_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Action::mutable_dependents() {
  return &dependents_;
}

// optional int32 num_dependencies = 54;
inline bool Action::has_num_dependencies() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Action::set_has_num_dependencies() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Action::clear_has_num_dependencies() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Action::clear_num_dependencies() {
  num_dependencies_ = 0;
  clear_has_num_dependencies();
}
inline ::google::protobuf::int32 Action::num_dependencies() const {
  return num_dependencies_;
}
inline void Action::set_num_dependencies(::google::protobuf::int32 value) {
  set_has_num_dependencies();
  num_dependencies_ = value;
}

// optional bool materialize = 55;
inline bool Action::has_materialize() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Action::set_has_materialize() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Action::clear_has_materialize() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Action::clear_materialize() {
  materialize_ = false;
  clear_has_materialize();
}
inline bool Action::materialize() const {
  return materialize_;
}
inline void Action::set_materialize(bool value) {
  set_has_materialize();
  materialize_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_action_5fint_2eproto__INCLUDED
